;;; Random access lists are a data structure like lists, which offer an efficient cons, car and
;;; cdr, but they also allow referring and setting values from the middle of the the list without
;;; having to walk all the way to the position.
;;;
;;; This library is a test implementation of random access lists implemented in part as
;;; executable functions. The implementation is written so that it does not depend on
;;; bignum arithmentic. As a consequence the maximum length of a value that can be referred
;;; from the middle of the list is bound by fixnum size to 16777215. The data structure itself
;;; does not impose any limits on number of elements.
;;;
;;; The idea of the data structure consists of two parts. First in order to maintain efficient
;;; access to elements in the list, the data structure grows a forest of complete binary trees
;;; of the values. The first tree is always of height 0, allowing an O(1) car, a following tree
;;; is always either of snd height or *one* level taller, and twice as large, than the previous one,
;;; and there are always at most *two* trees of the snd height next to each other.
;;;
;;; Given these invariants, it is easy to see that it takes O(log n) steps to find the tree in
;;; which some particular value is held, and then another O(log n) steps to walk the tree to
;;; a given position. Because the elements of the tree are kept in order, it is possible to
;;; use the bits of the index to choose tree branches when finding a particular value from
;;; a tree in which it is known to be.
;;;
;;; The initial version mainly has rcons, rnull and rget, which act like cons, null and lref.
;;;

(define-library (owl rlist-lcb)

   (import
      (owl defmac)
      (owl list))

   (export
      rnull
      rcons
      rget
      rcar
      rcdr
      rlist
      rfold
      rnull?
      node-case
      list->rlist
      rlist->list)

   (begin

      (define (snd x t)
         (λ (s d e) (s x t)))

      (define (fst x t)
         (λ (s d e) (d x t)))

      (define (rnull s d e) (e))

      ;; these could be autogenerated later
      (define-syntax node-case
         (syntax-rules (snd fst null _bind)
            ((node-case _bind elem () (s d n) ())
               (elem s d n))

            ;; allow passing a precomputed thunk, since it's often fixed
            ((node-case _bind elem (null fst snd) () (pre ... (null nthunk) post ...))
             (node-case _bind elem (fst snd) (nthunk) (pre ... post ...)))
            ((node-case _bind elem (null fst snd) () (pre ... ((null) nval) post ...))
             (node-case _bind elem (fst snd) ((λ () nval)) (pre ... post ...)))
            ((node-case _bind elem (null fst snd) () bindings)
             (node-case _bind elem (fst snd) (#f) bindings))

            ((node-case _bind elem (fst snd) (nval) (pre ... ((fst a b) . val) post ...))
             (node-case _bind elem (snd) ((λ (a b) . val) nval) (pre ... post ...)))
            ((node-case _bind elem (fst snd) (nval) bindings)
             (node-case _bind elem (snd) (#f nval) bindings))

            ((node-case _bind elem (snd) (dval nval) (((snd a b) . val)))
             (node-case _bind elem () ((λ (a b) . val) dval nval) ()))
            ((node-case _bind elem (snd) (dval nval) ())
             (node-case _bind elem () (#f dval nval) ()))

            ((node-case (op . args) . stuff)
               (let ((node (op . args)))
                  (node-case node . stuff)))
            ((node-case _bind . stuff)
               (syntax-error "bad node-case situation:" (node-case _bind . stuff)))
            ((node-case elem . bindings)
               ;; start finding cases, fill empty ones with elem itsel
               (node-case _bind elem (null fst snd) () bindings))))

      (define (rcons x as)
         (node-case as
            ((fst a bs)
               (node-case bs
                  ((snd b cs)
                     (node-case cs
                        ((fst v d)
                           (fst x (rcons (cons a b) cs)))
                        ((null) (fst x (fst (cons a b) rnull)))))
                  ((fst z cs) (fst x (snd a bs)))
                  ((null) (fst x (snd a rnull)))))
            ((null) (fst x rnull))))

      (define (rcar rl def)
         (node-case rl
            ((fst a rl) a)
            ((null) def)))

      (define (tof) #f)

      (define rcar
         (case-lambda
            ((rl)
               (node-case rl
                  ((fst a rl) a)
                  (null tof)))
            ((rl def)
               (node-case rl
                  ((fst a rl) a)
                  ((null) def)))))

      (define rnull?
         (let ((y (λ () #t))
               (n (λ (a b) #f)))
            (λ (rl) (rl n n y))))

      (define (drop as)
         (node-case as
            ((null)
               rnull)
            ((snd a bs)
               (fst a bs))
            ((fst ab cs)
               (fst (car ab)
                  (snd (cdr ab)
                     (drop cs))))))

      (define (rcdr as)
         (node-case as
            ((fst a bs) (drop bs))
            ((null) rnull)))

      (define (pick tree path depth)
         (if (eq? depth 1)
            tree
            (lets ((depth _ (fx>> depth 1)))
               (if (eq? (fxband path depth) 0)
                  (pick (car tree) path depth)
                  (pick (cdr tree) path depth)))))

      (define (rget rl pos def)
         (let loop ((rl rl) (d 0) (dp 1) (pos pos))
            (node-case rl
               ((snd tree rl)
                  (lets ((posp u (fx- pos d)))
                     (if u
                        (pick tree pos d)
                        (loop rl d dp posp))))
               ((fst tree rl)
                  (lets
                     ((d dp)
                      (dp o (fx+ dp dp))
                      (posp u (fx- pos d)))
                     (if u
                        (pick tree pos d)
                        (loop rl d dp posp))))
               ((null) def))))

      (define (rfold-node op st n d)
         (if (eq? d 1)
            (op st n)
            (lets ((d _ (fx>> d 1)))
               (rfold-node op (rfold-node op st (car n) d) (cdr n) d))))

      (define (rfold op st rl)
         (let loop ((rl rl) (st st) (depth 0))
            (node-case rl
               ((snd a rl)
                  (loop rl (rfold-node op st a depth) depth))
               ((fst a rl)
                  (if (eq? depth 0)
                     (loop rl (op st a) 1)
                     (lets ((depth o (fx+ depth depth)))
                        (loop rl
                           (rfold-node op st a depth)
                           depth))))
               ((null) st))))

      (define (list->rlist x)
         (foldr rcons rnull x))

      (define (rlist->list rl)
         (reverse (rfold (λ (pre val) (cons val pre)) '() rl)))

      (define (rlist . args)
         (list->rlist args))

))
