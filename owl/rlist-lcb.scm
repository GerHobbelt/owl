;;; Random access lists are a data structure like lists, which offer an efficient cons, car and
;;; cdr, but they also allow referring and setting values from the middle of the the list without
;;; having to walk all the way to the position.
;;;
;;; This library is a test implementation of random access lists implemented in part as
;;; executable functions. The implementation is written so that it does not depend on
;;; bignum arithmentic. As a consequence the maximum length of a value that can be referred
;;; from the middle of the list is bound by fixnum size to 16777215. The data structure itself
;;; does not impose any limits on number of elements.
;;;
;;; The idea of the data structure consists of two parts. First in order to maintain efficient
;;; access to elements in the list, the data structure grows a forest of complete binary trees
;;; of the values. The first tree is always of height 0, allowing an O(1) car, a following tree
;;; is always either of same height or *one* level taller, and twice as large, than the previous one,
;;; and there are always at most *two* trees of the same height next to each other.
;;;
;;; Given these invariants, it is easy to see that it takes O(log n) steps to find the tree in
;;; which some particular value is held, and then another O(log n) steps to walk the tree to
;;; a given position. Because the elements of the tree are kept in order, it is possible to
;;; use the bits of the index to choose tree branches when finding a particular value from
;;; a tree in which it is known to be.
;;;
;;; The initial version mainly has rcons, rnull and rget, which act like cons, null and lref.
;;;

(define-library (owl rlist-lcb)

   (import
      (owl defmac)
      (owl list))

   (export
      rnull
      rcons
      rget
      rcar
      ;rcdr
      rlist
      rfold
      node-case
      list->rlist
      rlist->list)

   (begin

      (define (same x t)
         (λ (s d e) (s x t)))

      (define (double x t)
         (λ (s d e) (d x t)))

      (define (rnull s d e) e)

      ;; these could be autogenerated later
      (define-syntax node-case
         (syntax-rules (same double null _bind)
            ((node-case _bind elem () (s d n) ())
               (elem s d n))
            ((node-case _bind elem (null double same) () (pre ... (null nval) post ...))
             (node-case _bind elem (double same) (nval) (pre ... post ...)))
            ((node-case _bind elem (null double same) () bindings)
             (node-case _bind elem (double same) (#f) bindings))

            ((node-case _bind elem (double same) (nval) (pre ... ((double a b) . val) post ...))
             (node-case _bind elem (same) ((λ (a b) . val) nval) (pre ... post ...)))
            ((node-case _bind elem (double same) (nval) bindings)
             (node-case _bind elem (same) (#f nval) bindings))

            ((node-case _bind elem (same) (dval nval) (((same a b) . val)))
             (node-case _bind elem () ((λ (a b) . val) dval nval) ()))
            ((node-case _bind elem (same) (dval nval) ())
             (node-case _bind elem () (#f dval nval) ()))

            ((node-case (op . args) . stuff)
               (let ((node (op . args)))
                  (node-case node . stuff)))
            ((node-case _bind . stuff)
               (syntax-error "bad node-case situation:" (node-case _bind . stuff)))
            ((node-case elem . bindings)
               ;; start finding cases, fill empty ones with elem itsel
               (node-case _bind elem (null double same) () bindings))))

      (define (rcons x as)
         (node-case as
            ((double a bs)
               (node-case bs
                  ((same b cs)
                     (node-case cs
                        ((double v d)
                           (double x (rcons (cons a b) cs)))
                        (null (double x (double (cons a b) rnull)))))
                  ((double z cs) (double x (same a bs)))
                  (null (double x (same a rnull)))))
            (null (double x rnull))))

      (define (rcar rl def)
         (node-case rl
            ((double a rl) a)
            (null def)))

      (define (pick tree path depth)
         (if (eq? depth 1)
            tree
            (lets ((depth _ (fx>> depth 1)))
               (if (eq? (fxband path depth) 0)
                  (pick (car tree) path depth)
                  (pick (cdr tree) path depth)))))

      (define (rget rl pos def)
         (let loop ((rl rl) (d 0) (dp 1) (pos pos))
            (rl
               (λ (tree rl)
                  (lets ((posp u (fx- pos d)))
                     (if u
                        (pick tree pos d)
                        (loop rl d dp posp))))
               (λ (tree rl)
                  (lets
                     ((d dp)
                      (dp o (fx+ dp dp))
                      (posp u (fx- pos d)))
                     (if u
                        (pick tree pos d)
                        (loop rl d dp posp))))
               def)))

      (define (rfold-node op st n d)
         (if (eq? d 1)
            (op st n)
            (lets ((d _ (fx>> d 1)))
               (rfold-node op (rfold-node op st (car n) d) (cdr n) d))))

      (define (rfold op st rl)
         (let loop ((rl rl) (st st) (depth 0))
            (node-case rl
               ((same a rl)
                  (loop rl (rfold-node op st depth a) depth))
               ((double a rl)
                  (if (eq? depth 0)
                     (loop rl (op st a) 1)
                     (lets ((depth o (fx+ depth depth)))
                        (loop rl
                           (rfold-node op st a depth)
                           depth))))
               (null st))))

      (define (list->rlist x)
         (foldr rcons rnull x))

      (define (rlist->list rl)
         (reverse (rfold (λ (pre val) (cons val pre)) '() rl)))

      (define (rlist . args)
         (list->rlist args))

))
