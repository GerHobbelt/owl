;;;
;;; random access lists
;;;

(define-library (owl rlist old)

   (export
      rnull
      rcons  ; O(1), (rcons a rl) -> rl'
      rcar   ; O(1), (rcar (rcons a rl)) -> a
      rcdr   ; O(1), (rcdr (rcons a rl)) -> rl'*
      rnull? ; O(1), plain null?
      rpair?
      rlist? ; O(1), obj -> bool
      rget   ; O(log n), (rget rl pos def) -> val | def if outside of rl
      rset   ; O(log n), (rset rl pos val) -> rl' | error if outside of rl
      rlen   ; O(log n)
      rfold ; O(n), like fold
      rfoldr ; O(n), like foldr
      rmap ; O(n), like map
      riter ; O(n), rlist -> lazy list (aka iterator) **
      riterr ; O(n), ditto backwards
      requal?     ; O(n)***
      rlist->list ; O(n)
      list->rlist ; O(n log n), temp
      rlist  ; (rlist ...) -> rl
            rrev        ; O(n log n)
   )

   ; *   (equal? rl rl') = #true, but not necessarily (eq? rl rl')
   ; **  you can therefore use all lib-lazy list functions
   ; *** normal equal? will do because the representation is unique

   ; note, taken primitive type 10 for spines, variant 42 for nodes
   ; ie cannot store a node of type 42 into a rlist (which would be a
   ; major abstraction violation anyway).

   (import
      (owl defmac)
      (owl list)
      (owl math)
      (owl equal)
      (only (owl syscall) error))

   (begin

      (define rnull #n)

      (define rnull? null?)

      (define (rpair? x) (not (rnull? x)))

      (define (rlist? l)
         (cond
            ((null? l) #true)
            ((eq? (type l) 10) #true)
            (else #false)))

      ;; constructors, later autogenerated

      (define-syntax node
         (syntax-rules ()
            ((node a l r) (mkt type-rlist-node a l r))))

      (define-syntax if-node
         (syntax-rules ()
            ((if-node val a b)
               (if (eq? (type val) type-rlist-node)
                  a b))))

      (define-syntax spine
         (syntax-rules ()
            ((spine w t rl) (mkt type-rlist-spine w t rl))))

      ;; cons

      (define (rcons a rl)
         (if (null? rl)
            (spine 1 a rl)
            (lets ((w1 t1 tl rl))
               (if (null? tl)
                  (spine 1 a rl)
                  (lets ((w2 t2 ttl tl))
                     (if (= w1 w2)
                        (spine (+ (+ w1 w2) 1) (node a t1 t2) ttl)
                        (spine 1 a rl)))))))

      ;; car & cdr

      (define (rcar rl)
         (lets ((w a tl rl))
            (if-node a (ref a 1) a)))

      (define (rcdr rl)
         (lets ((w n tl rl))
            (if-node n
               (lets ((x a b n) (w (>> w 1)))
                  (spine w a (spine w b tl)))
               tl)))

      ;; get

      (define (rget-tree n w p)
         (if (eq? p 0)
            (if-node n (ref n 1) n)
            (lets ((a t1 t2 n) (wp (>> w 1)))
               (if (<= p wp)
                  (rget-tree t1 wp (- p 1))
                  (rget-tree t2 wp (- p (+ wp 1)))))))

      (define (rget rl pos def)
         (if (null? rl)
            def
            (lets ((w t tl rl))
               (if (< pos w)
                  (rget-tree t w pos)
                  (rget tl (- pos w) def)))))

      ;; set

      (define (rset-tree n w p v)
         (if (eq? p 0)
            (if-node n (set n 1 v) v)
            (lets ((a t1 t2 n) (wp (>> w 1)))
               (if (<= p wp)
                  (set n 2 (rset-tree t1 wp (- p 1) v))
                  (set n 3 (rset-tree t2 wp (- p (+ wp 1)) v))))))

      (define (rset rl pos val)
         (if (null? rl)
            (error "rset: out of list setting " val)
            (lets ((w t tl rl))
               (if (< pos w)
                  (spine w (rset-tree t w pos val) tl)
                  (spine w t (rset tl (- pos w) val))))))

      ;; map

      (define (rmap-tree n op)
         (if-node n
            (lets ((a t1 t2 n))
               (node (op a)
                  (rmap-tree t1 op)
                  (rmap-tree t2 op)))
            (op n)))

      (define (rmap op rl)
         (if (null? rl)
            #n
            (lets ((w t tl rl))
               (spine w (rmap-tree t op) (rmap op tl)))))

      ;; riter (forwards)

      ; note, this generates (log t) of tree size t in one run
      ; to reduce the overhead. insert a lambda after the cons
      ; to get just one at a time.

      (define (riter-tree n tail)
         (if-node n
            (lets ((a t1 t2 n))
               (cons a
                  (riter-tree t1
                     (lambda () (riter-tree t2 tail)))))
            (cons n tail)))

      (define (riterator rl tail)
         (if (null? rl)
            tail
            (lets ((w t tl rl))
               (riter-tree t
                  (lambda () (riterator tl tail))))))

      (define riter (C riterator #n))

      ;; riterr (backwards)

      (define (riterr-tree n tail)
         (if-node n
            (lets ((a t1 t2 n) (tail (cons a tail)))
               (riterr-tree t2
                  (lambda ()
                     (riterr-tree t1 tail))))
            (cons n tail)))

      (define (riteratorr rl tail)
         (if (null? rl)
            tail
            (lets ((w t tl rl))
               (riteratorr tl
                  (lambda ()
                     (riterr-tree t tail))))))

      (define riterr (C riteratorr #n))

      ;; rfold (== (lfold op st (riter rl)))

      (define (rfold-tree op st n)
         (if-node n
            (lets
               ((a t1 t2 n)
                (st (op st a))
                (st (rfold-tree op st t1)))
               (rfold-tree op st t2))
            (op st n)))

      (define (rfold op st rl)
         (if (null? rl)
            st
            (lets ((w t tl rl))
               (rfold op (rfold-tree op st t) tl))))

      ;; rfoldr (== (lfoldr op st (riterr rl)))

      (define (rfoldr-tree op st n)
         (if-node n
            (lets
               ((a t1 t2 n)
                (st (rfoldr-tree op st t2))
                (st (rfoldr-tree op st t1)))
               (op a st))
            (op n st)))

      (define (rfoldr op st rl)
         (if (null? rl)
            st
            (lets ((w t tl rl))
               (rfoldr-tree op (rfoldr op st tl) t))))

      ;; conversions

      (define (list->rlist l) ; naive O(n log n)
         (foldr rcons #n l))

      (define (rlist->list rl)
         (rfoldr cons #n rl))

      ;; len

      (define (rlen rl)
         (let loop ((rl rl) (l 0))
            (if (null? rl)
               l
               (lets ((w a tl rl))
                  (loop tl (+ l w))))))

      ;; comparison

      (define requal? equal?)

      (define-syntax rlist
         (syntax-rules ()
            ((rlist) #n)
            ((rlist a . as)
               (rcons a (rlist . as)))))

   ;; note, could also be done in O(n)
   (define (rrev rl)
      (rfold (Î» (out x) (rcons x out)) #n rl))

))

