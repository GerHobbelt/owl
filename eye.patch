diff --git a/c/ovm.c b/c/ovm.c
index 19e9c1f..123c3d3 100644
--- a/c/ovm.c
+++ b/c/ovm.c
@@ -13,7 +13,8 @@
 #include <dirent.h>
 #include <string.h>
 
-/* Portability Issues */
+
+/*** Portability Issues ***/
 
 #ifdef WIN32 
 #include <winsock2.h>
@@ -43,8 +44,10 @@ typedef unsigned long in_addr_t;
 #define EXIT(n) exit(n)
 #endif
 
-/* Macros */
 
+/*** Macros ***/
+
+#define SPOS                        15 /* current position of size bits in header, on the way to 16 */
 #define word                        uintptr_t
 #define V(ob)                       *((word *) (ob))
 #define W                           sizeof(word)
@@ -52,9 +55,9 @@ typedef unsigned long in_addr_t;
 #define FBITS                       16           /* bits in fixnum (and immediate payload width) */
 #define FMAX                        0xffff       /* max fixnum (2^FBITS-1) */
 #define MAXOBJ                      0xffff       /* max words in tuple including header */
-#define make_immediate(value, type) (((value) << 12) | ((type) << 3) | 2)
-#define make_header(size, type)     (((size) << 12)  | ((type) << 3) | 6)
-#define make_raw_header(size, type) (((size) << 12)  | ((type) << 3) | 2054)
+#define make_immediate(value, type) (((value) << 12)  | ((type) << 3) | 2)
+#define make_header(size, type)     (((size) << SPOS) | ((type) << 3) | 6)
+#define make_raw_header(size, type) (((size) << SPOS) | ((type) << 3) | 2054)
 #define headerp(val)                (((val) & 6) == 6)
 #define F(val)                      (((val) << 12) | 2) 
 #define BOOL(cval)                  ((cval) ? ITRUE : IFALSE)
@@ -66,11 +69,14 @@ typedef unsigned long in_addr_t;
 #define header(x)                   *(word *x)
 #define imm_type(x)                 (((x) >> 3) & 0xff)
 #define imm_val(x)                  ((x) >> 12)
+#define hdrsize(x)                  ((word) (((word)x) >> SPOS))
 #define immediatep(x)               (((word)x)&2)
 #define allocp(x)                   (!immediatep(x))
 #define rawp(hdr)                   ((hdr)&RAWBIT)
 #define NEXT(n)                     ip += n; op = *ip++; goto main_dispatch /* default NEXT, smaller vm */
 #define NEXT_ALT(n)                 ip += n; op = *ip++; EXEC /* faster for newer machines, bigger vm */
+#define PAIRHDR                     make_header(3,1) /* 196622 */
+#define NUMHDR                      make_header(3,9) /* 196686 */
 #define pairp(ob)                   (allocp(ob) && V(ob)==PAIRHDR)
 #define INULL                       10
 #define IFALSE                      18
@@ -95,10 +101,7 @@ typedef unsigned long in_addr_t;
 #define A5                          R[ip[5]]
 #define G(ptr,n)                    ((word *)(ptr))[n]
 #define flagged_or_raw(hdr)         (hdr&2049)
-#define hdrsize(hdr)                imm_val(hdr)
 #define TICKS                       10000 /* # of function calls in a thread quantum  */
-#define PAIRHDR                     12302
-#define NUMHDR                      12366
 #define allocate(size, to)          to = fp; fp += size;
 #define error(opcode, a, b)         R[4] = F(opcode); R[5] = (word) a; R[6] = (word) b; goto invoke_mcp;
 #define likely(x)                   __builtin_expect((x),1)
@@ -109,6 +112,7 @@ typedef unsigned long in_addr_t;
 #define RET(n)                      ob=(word *)R[3]; R[3] = R[n]; acc = 1; goto apply
 #define MEMPAD                      (NR+2)*8 /* space at end of heap for starting GC */
 #define MINGEN                      1024*32  /* minimum generation size before doing full GC  */
+#define INITCELLS                   1000000
 #define OCLOSE(proctype)            { word size = *ip++, tmp; word *ob; allocate(size, ob); tmp = R[*ip++]; tmp = ((word *) tmp)[*ip++]; *ob = make_header(size, proctype); ob[1] = tmp; tmp = 2; while(tmp != size) { ob[tmp++] = R[*ip++]; } R[*ip++] = (word) ob; }
 #define CLOSE1(proctype)            { word size = *ip++, tmp; word *ob; allocate(size, ob); tmp = R[1]; tmp = ((word *) tmp)[*ip++]; *ob = make_header(size, proctype); ob[1] = tmp; tmp = 2; while(tmp != size) { ob[tmp++] = R[*ip++]; } R[*ip++] = (word) ob; }
 #define EXEC switch(op&63) { \
@@ -125,7 +129,7 @@ typedef unsigned long in_addr_t;
       case 58: goto op58; case 59: goto op59; case 60: goto op60; case 61: goto op61; case 62: goto op62; case 63: goto op63; \
    }
 
-/* Globals and Prototypes */
+/*** Globals and Prototypes ***/
 
 /* memstart <= genstart <= memend */
 static word *genstart;
@@ -148,7 +152,8 @@ char *getenv(const char *name);
 DIR *opendir(const char *name);
 DIR *fdopendir(int fd);
 
-/* Garbage Collector, based on "Efficient Garbage Compaction Algorithm" by Johannes Martin (1982) */
+
+/*** Garbage Collector, based on "Efficient Garbage Compaction Algorithm" by Johannes Martin (1982) ***/
 
 static __inline__ void rev(word pos) {
    word val = V(pos);
@@ -168,7 +173,7 @@ static __inline__ word *chase(word *pos) {
    return pos;
 }
 
-static void marks(word *pos, word *end) {
+static void mark(word *pos, word *end) {
    while (pos != end) {
       word val = *pos;
       if (allocp(val) && val >= ((word) genstart)) { 
@@ -245,8 +250,9 @@ int adjust_heap(int cells) {
    word *old = memstart;
    word nwords = memend - memstart + MEMPAD; /* MEMPAD is after memend */
    word new_words = nwords + cells;
-   if (!usegc) /* only run when the vm is running (temp) */
+   if (!usegc) { /* only run when the vm is running (temp) */
       return 0;
+   }
    if (seccompp) /* realloc is not allowed within seccomp */
       return 0;
    memstart = realloc(memstart, new_words*W);
@@ -265,20 +271,54 @@ int adjust_heap(int cells) {
    }
 }
 
+/* memstart                                      end
+    v                                            v
+   [hdr f1 ... fn]Â [hdr ...] ... [hdr f1 .. fm]  
+   should work at any point in program operation when run for fp
+ */
+void check_heap(word *fp) {
+	word *pos = memstart;
+	while (pos < fp) {
+		word h = *pos;
+		int s = hdrsize(h); /* <- looking for potential sign issues in type promotion */
+		if (!headerp(h))
+			fprintf(stderr, "DEBUG: object has a non-header first field\n");
+		if (s < 0 || s > 0xffff)
+			fprintf(stderr, "DEBUG: object has a bad size \n");
+		if (rawp(h)) {
+			pos += s;
+		} else {
+			s--; pos++; /* skip header */
+			while(s--) {
+				word f = *pos++;
+				if (immediatep(f)) 
+					continue;
+				if ((word) f > (word) pos) 
+					fprintf(stderr, "DEBUG: up-pointer in heap\n");
+				if (!headerp(V(f)))
+					fprintf(stderr, "DEBUG: pointer to non-header\n");
+			}
+		}
+   }
+   if (pos != fp)
+      fprintf(stderr, "DEBUG: heap didn't end exactly where it should have\n");
+}
+
 /* input desired allocation size and root object, 
    return a pointer to the same object after compaction, resizing, possible heap relocation etc */
 static word *gc(int size, word *regs) {
    word *root;
    word *realend = memend;
    int nfree, nused;
-   fp = regs + imm_val(*regs);
+   fp = regs + hdrsize(*regs);
+	check_heap(fp); /* pre GC heap integrity check */
    root = fp+1;
    *root = (word) regs;
-   fflush(stdout);
    memend = fp;
-   marks(root, fp);
+   mark(root, fp);
    fp = compact();
    regs = (word *) *root;
+	check_heap(regs + hdrsize(*regs)); /* post GC heap integrity check */
    memend = realend;
    nfree = (word)memend - (word)regs;
    nused = (word)regs - (word)genstart; 
@@ -291,7 +331,7 @@ static word *gc(int size, word *regs) {
       nfree -= size*W + MEMPAD;   /* how much really could be snipped off */
       if (nfree < (heapsize / 20) || nfree < 0) {
          /* increase heap size if less than 5% is free by ~10% of heap size (growth usually implies more growth) */
-         regs[imm_val(*regs)] = 0; /* use an invalid descriptor to denote end live heap data  */
+         regs[hdrsize(*regs)] = 0; /* use an invalid descriptor to denote end live heap data  */
          regs = (word *) ((word)regs + adjust_heap(size*W + nused/10 + 4096));
          nfree = memend - regs;
          if (nfree <= size) {
@@ -304,7 +344,7 @@ static word *gc(int size, word *regs) {
          int dec = -(nfree/10);
          int new = nfree - dec;
          if (new > size*W*2 + MEMPAD) {
-            regs[imm_val(*regs)] = 0; /* as above */
+            regs[hdrsize(*regs)] = 0; /* as above */
             regs = (word *) ((word)regs + adjust_heap(dec+MEMPAD*W));
             heapsize = (word) memend - (word) memstart; 
             nfree = (word) memend - (word) regs; 
@@ -325,7 +365,8 @@ static word *gc(int size, word *regs) {
    return regs;
 }
 
-/* OS Interaction and Helpers */
+
+/*** OS Interaction and Helpers ***/
 
 void set_nonblock (int sock) {
 #ifdef WIN32
@@ -484,7 +525,8 @@ unsigned char *load_heap(char *path) {
    return hp;
 }
 
-/* Primops called from VM and generated C-code */
+
+/*** Primops called from VM and generated C-code ***/
 
 static word prim_connect(word *host, word port) {
    int sock;
@@ -543,7 +585,7 @@ static word prim_cast(word *ob, int type) {
       word *new, *res; /* <- could also write directly using *fp++ */
       allocate(size, new);
       res = new;
-      /* #b11111111111111111111100000000111 */
+      /* (hdr & 0b...11111111111111111111100000000111) | tttttttt000 */
       *new++ = (hdr&(~2040))|(type<<3);
       wordcopy(ob,new,size-1);
       return (word)res;
@@ -556,7 +598,7 @@ static int prim_refb(word pword, int pos) {
    if (immediatep(ob))
       return -1;
    hdr = *ob;
-   hsize = ((imm_val(hdr)-1)*W) - ((hdr>>8)&7); /* bytes - pads */ 
+   hsize = ((hdrsize(hdr)-1)*W) - ((hdr>>8)&7); /* bytes - pads */ 
    if (pos >= hsize) 
       return IFALSE;
    return F(((unsigned char *) ob)[pos+W]);
@@ -569,11 +611,11 @@ static word prim_ref(word pword, word pos)  {
    if(immediatep(ob)) { return IFALSE; }
    hdr = *ob;
    if (rawp(hdr)) { /* raw data is #[hdrbyte{W} b0 .. bn 0{0,W-1}] */ 
-      size = ((imm_val(hdr)-1)*W) - ((hdr>>8)&7);
+      size = ((hdrsize(hdr)-1)*W) - ((hdr>>8)&7);
       if (pos >= size) { return IFALSE; }
       return F(((unsigned char *) ob)[pos+W]);
    }
-   size = imm_val(hdr);
+   size = hdrsize(hdr);
    if (!pos || size <= pos) /* tuples are indexed from 1 (probably later 0-255)*/
       return IFALSE;
    return ob[pos];
@@ -587,8 +629,8 @@ static word prim_set(word wptr, word pos, word val) {
    pos = fixval(pos);
    if(immediatep(ob)) { return IFALSE; }
    hdr = *ob;
-   if (rawp(hdr) || imm_val(hdr) < pos) { return IFALSE; }
-   hdr = imm_val(hdr); /* get size */
+   if (rawp(hdr) || hdrsize(hdr) < pos) { return IFALSE; }
+   hdr = hdrsize(hdr);
    allocate(hdr, new);
    while(p <= hdr) {
       new[p] = (pos == p && p) ? val : ob[p];
@@ -605,7 +647,7 @@ static word prim_sys(int op, word a, word b, word c) {
          word *buff = (word *) b;
          int wrote, size, len = fixval(c);
          if (immediatep(buff)) return IFALSE;
-         size = (imm_val(*buff)-1)*W;
+         size = (hdrsize(*buff)-1)*W;
          if (len > size) return IFALSE;
          wrote = write(fd, ((char *)buff)+W, len);
          if (wrote > 0) return F(wrote);
@@ -751,7 +793,7 @@ static word prim_sys(int op, word a, word b, word c) {
          word *buff = (word *) b;
          int wrote, size, len = fixval(c);
          if (immediatep(buff)) return IFALSE;
-         size = (imm_val(*buff)-1)*W;
+         size = (hdrsize(*buff)-1)*W;
          if (len > size) return IFALSE;
          wrote = send(fd, ((char *)buff)+W, len, 0); /* <- no MSG_DONTWAIT in win32 */
          if (wrote > 0) return F(wrote);
@@ -839,9 +881,9 @@ word boot(int nargs, char **argv) {
       hp = (unsigned char *) &heap;
    }
    max_heap_mb = (W == 4) ? 4096 : 65535; /* can be set at runtime */
-   memstart = genstart = fp = (word *) realloc(NULL, (FMAX + MEMPAD)*W); /* at least one argument string always fits */
+   memstart = genstart = fp = (word *) realloc(NULL, (INITCELLS + FMAX + MEMPAD)*W); /* at least one argument string always fits */
    if (!memstart) exit(3);
-   memend = memstart + FMAX - MEMPAD;
+   memend = memstart + FMAX + INITCELLS - MEMPAD;
    this = nargs-1;
    usegc = 1;
    while(this >= 0) { /* build an owl string list to oargs at bottom of heap */
@@ -914,6 +956,7 @@ word vm(word *ob, word *args) {
    static word R[NR];
    word load_imms[] = {F(0), INULL, ITRUE, IFALSE};  /* for ldi and jv */
    usegc = 1; /* enble gc (later have if always evabled) */
+   //fprintf(stderr, "VM STARTED\n");
 
    /* clear blank regs */
    while(acc < NR) { R[acc++] = INULL; }
@@ -923,6 +966,7 @@ word vm(word *ob, word *args) {
    acc = 2; /* boot always calls with 2 args*/
 
 apply: /* apply something at ob to values in regs, or maybe switch context */
+   //fprintf(stderr, "VM APPLY\n");
    if (likely(allocp(ob))) {
       word hdr = *ob & 4095;
       if (hdr == 262) { /* proc  */ 
@@ -1005,7 +1049,9 @@ switch_thread: /* enter mcp if present */
       goto apply;
    }
 invoke: /* nargs and regs ready, maybe gc and execute ob */
-   if (((word)fp) + 1024*64 >= ((word) memend)) { /* <- fixme... can be lowered after the compiler pass */
+   if (((word)fp) + 1024*64 >= ((word) memend))
+      //(1)  // always gc
+	{
       int p = 0; 
       *fp = make_header(NR+2, 50); /* hdr r_0 .. r_(NR-1) ob */ 
       while(p < NR) { fp[p+1] = R[p]; p++; } 
@@ -1020,6 +1066,7 @@ invoke: /* nargs and regs ready, maybe gc and execute ob */
 
    if (op) {
       main_dispatch:
+      //fprintf(stderr, "vm: %d\n", op);
       EXEC;
    } else {
       op = *ip<<8 | ip[1];
@@ -1226,7 +1273,7 @@ invoke: /* nargs and regs ready, maybe gc and execute ob */
       word hdr, pos = 1, n = *ip++;
       assert(allocp(tuple), tuple, 32);
       hdr = *tuple;
-      assert_not((rawp(hdr) || fixval(hdr)-1 != n), tuple, 32);
+      assert_not((rawp(hdr) || hdrsize(hdr)-1 != n), tuple, 32);
       while(n--) { R[*ip++] = tuple[pos++]; }
       NEXT(0); }
    op33: { /* jrt a t o, jump by raw type (ignoring padding info) */
@@ -1254,7 +1301,7 @@ invoke: /* nargs and regs ready, maybe gc and execute ob */
       NEXT(4); }
    op36: { /* size o r */
       word *ob = (word *) R[*ip++];
-      R[*ip++] = (immediatep(ob)) ? F(0) : F(imm_val(*ob)-1);
+      R[*ip++] = (immediatep(ob)) ? F(0) : F(hdrsize(*ob)-1);
       NEXT(0); }
    op37: { /* ms r */
 #ifndef WIN32
diff --git a/eye.patch b/eye.patch
index cb3fb7b..ba422ab 100644
--- a/eye.patch
+++ b/eye.patch
@@ -1,252 +0,0 @@
-diff --git a/c/ovm.c b/c/ovm.c
-index c1ea169..f18883c 100644
---- a/c/ovm.c
-+++ b/c/ovm.c
-@@ -53,8 +53,8 @@ typedef unsigned long in_addr_t;
- #define FMAX                        0xffff       /* max fixnum (2^FBITS-1) */
- #define MAXOBJ                      0xffff       /* max words in tuple including header */
- #define make_immediate(value, type) (((value) << 12) | ((type) << 3) | 2)
--#define make_header(size, type)     (((size) << 12)  | ((type) << 3) | 6)
--#define make_raw_header(size, type) (((size) << 12)  | ((type) << 3) | 2054)
-+#define make_header(size, type)     (((size) << 16)  | ((type) << 3) | 6)
-+#define make_raw_header(size, type) (((size) << 16)  | ((type) << 3) | 2054)
- #define headerp(val)                (((val) & 6) == 6)
- #define F(val)                      (((val) << 12) | 2) 
- #define BOOL(cval)                  ((cval) ? ITRUE : IFALSE)
-@@ -66,11 +66,14 @@ typedef unsigned long in_addr_t;
- #define header(x)                   *(word *x)
- #define imm_type(x)                 (((x) >> 3) & 0xff)
- #define imm_val(x)                  ((x) >> 12)
-+#define hdrsize(x)                  (((word)x) >> 16)
- #define immediatep(x)               (((word)x)&2)
- #define allocp(x)                   (!immediatep(x))
- #define rawp(hdr)                   ((hdr)&RAWBIT)
- #define NEXT(n)                     ip += n; op = *ip++; goto main_dispatch /* default NEXT, smaller vm */
- #define NEXT_ALT(n)                 ip += n; op = *ip++; EXEC /* faster for newer machines, bigger vm */
-+#define PAIRHDR                     196622 /* make_header(3,1)*/
-+#define NUMHDR                      196686 /* make_header(3,9*/
- #define pairp(ob)                   (allocp(ob) && V(ob)==PAIRHDR)
- #define INULL                       10
- #define IFALSE                      18
-@@ -95,10 +98,7 @@ typedef unsigned long in_addr_t;
- #define A5                          R[ip[5]]
- #define G(ptr,n)                    ((word *)(ptr))[n]
- #define flagged_or_raw(hdr)         (hdr&2049)
--#define hdrsize(hdr)                imm_val(hdr)
- #define TICKS                       10000 /* # of function calls in a thread quantum  */
--#define PAIRHDR                     12302
--#define NUMHDR                      12366
- #define allocate(size, to)          to = fp; fp += size;
- #define error(opcode, a, b)         R[4] = F(opcode); R[5] = (word) a; R[6] = (word) b; goto invoke_mcp;
- #define likely(x)                   __builtin_expect((x),1)
-@@ -109,6 +109,7 @@ typedef unsigned long in_addr_t;
- #define RET(n)                      ob=(word *)R[3]; R[3] = R[n]; acc = 1; goto apply
- #define MEMPAD                      (NR+2)*8 /* space at end of heap for starting GC */
- #define MINGEN                      1024*32  /* minimum generation size before doing full GC  */
-+#define INITCELLS                   1000000
- #define OCLOSE(proctype)            { word size = *ip++, tmp; word *ob; allocate(size, ob); tmp = R[*ip++]; tmp = ((word *) tmp)[*ip++]; *ob = make_header(size, proctype); ob[1] = tmp; tmp = 2; while(tmp != size) { ob[tmp++] = R[*ip++]; } R[*ip++] = (word) ob; }
- #define CLOSE1(proctype)            { word size = *ip++, tmp; word *ob; allocate(size, ob); tmp = R[1]; tmp = ((word *) tmp)[*ip++]; *ob = make_header(size, proctype); ob[1] = tmp; tmp = 2; while(tmp != size) { ob[tmp++] = R[*ip++]; } R[*ip++] = (word) ob; }
- #define EXEC switch(op&63) { \
-@@ -168,11 +169,14 @@ static __inline__ word *chase(word *pos) {
-    return pos;
- }
- 
--static void marks(word *pos, word *end) {
-+static void mark(word *pos, word *end) {
-+   //fprintf(stderr, "mark %d\n", pos);
-    while (pos != end) {
-       word val = *pos;
-+      //fprintf(stderr, "mark at %d\n", pos);
-       if (allocp(val) && val >= ((word) genstart)) { 
-          if (flagged(val)) {
-+            //fprintf(stderr, "flagged\n");
-             pos = ((word *) flag(chase((word *) val))) - 1;
-          } else {
-             word hdr = V(val);
-@@ -180,6 +184,7 @@ static void marks(word *pos, word *end) {
-             if (flagged_or_raw(hdr)) {
-                pos--;
-             } else {
-+               fprintf(stderr, "stepping %d, header %d\n", hdrsize(hdr)-1);
-                pos = ((word *) val) + (hdrsize(hdr)-1);
-             }
-          }
-@@ -271,12 +276,14 @@ static word *gc(int size, word *regs) {
-    word *root;
-    word *realend = memend;
-    int nfree, nused;
--   fp = regs + imm_val(*regs);
-+   fprintf(stderr, "GC\n");
-+   fp = regs + hdrsize(*regs);
-    root = fp+1;
-    *root = (word) regs;
--   fflush(stdout);
-    memend = fp;
--   marks(root, fp);
-+   //fprintf(stderr, "GC AAAA\n");
-+   mark(root, fp);
-+   //fprintf(stderr, "GC BBBB\n");
-    fp = compact();
-    regs = (word *) *root;
-    memend = realend;
-@@ -291,7 +298,7 @@ static word *gc(int size, word *regs) {
-       nfree -= size*W + MEMPAD;   /* how much really could be snipped off */
-       if (nfree < (heapsize / 20) || nfree < 0) {
-          /* increase heap size if less than 5% is free by ~10% of heap size (growth usually implies more growth) */
--         regs[imm_val(*regs)] = 0; /* use an invalid descriptor to denote end live heap data  */
-+         regs[hdrsize(*regs)] = 0; /* use an invalid descriptor to denote end live heap data  */
-          regs = (word *) ((word)regs + adjust_heap(size*W + nused/10 + 4096));
-          nfree = memend - regs;
-          if (nfree <= size) {
-@@ -304,7 +311,7 @@ static word *gc(int size, word *regs) {
-          int dec = -(nfree/10);
-          int new = nfree - dec;
-          if (new > size*W*2 + MEMPAD) {
--            regs[imm_val(*regs)] = 0; /* as above */
-+            regs[hdrsize(*regs)] = 0; /* as above */
-             regs = (word *) ((word)regs + adjust_heap(dec+MEMPAD*W));
-             heapsize = (word) memend - (word) memstart; 
-             nfree = (word) memend - (word) regs; 
-@@ -322,6 +329,7 @@ static word *gc(int size, word *regs) {
-    } else {
-       genstart = regs; /* start new generation */
-    }
-+   fprintf(stderr, "GC OVER\n");
-    return regs;
- }
- 
-@@ -543,7 +551,7 @@ static word prim_cast(word *ob, int type) {
-       word *new, *res; /* <- could also write directly using *fp++ */
-       allocate(size, new);
-       res = new;
--      /* #b11111111111111111111100000000111 */
-+      /* (hdr & 0b...11111111111111111111100000000111) | tttttttt000 */
-       *new++ = (hdr&(~2040))|(type<<3);
-       wordcopy(ob,new,size-1);
-       return (word)res;
-@@ -556,7 +564,7 @@ static int prim_refb(word pword, int pos) {
-    if (immediatep(ob))
-       return -1;
-    hdr = *ob;
--   hsize = ((imm_val(hdr)-1)*W) - ((hdr>>8)&7); /* bytes - pads */ 
-+   hsize = ((hdrsize(hdr)-1)*W) - ((hdr>>8)&7); /* bytes - pads */ 
-    if (pos >= hsize) 
-       return IFALSE;
-    return F(((unsigned char *) ob)[pos+W]);
-@@ -569,11 +577,11 @@ static word prim_ref(word pword, word pos)  {
-    if(immediatep(ob)) { return IFALSE; }
-    hdr = *ob;
-    if (rawp(hdr)) { /* raw data is #[hdrbyte{W} b0 .. bn 0{0,W-1}] */ 
--      size = ((imm_val(hdr)-1)*W) - ((hdr>>8)&7);
-+      size = ((hdrsize(hdr)-1)*W) - ((hdr>>8)&7);
-       if (pos >= size) { return IFALSE; }
-       return F(((unsigned char *) ob)[pos+W]);
-    }
--   size = imm_val(hdr);
-+   size = hdrsize(hdr);
-    if (!pos || size <= pos) /* tuples are indexed from 1 (probably later 0-255)*/
-       return IFALSE;
-    return ob[pos];
-@@ -587,8 +595,8 @@ static word prim_set(word wptr, word pos, word val) {
-    pos = fixval(pos);
-    if(immediatep(ob)) { return IFALSE; }
-    hdr = *ob;
--   if (rawp(hdr) || imm_val(hdr) < pos) { return IFALSE; }
--   hdr = imm_val(hdr); /* get size */
-+   if (rawp(hdr) || hdrsize(hdr) < pos) { return IFALSE; }
-+   hdr = hdrsize(hdr);
-    allocate(hdr, new);
-    while(p <= hdr) {
-       new[p] = (pos == p && p) ? val : ob[p];
-@@ -605,7 +613,7 @@ static word prim_sys(int op, word a, word b, word c) {
-          word *buff = (word *) b;
-          int wrote, size, len = fixval(c);
-          if (immediatep(buff)) return IFALSE;
--         size = (imm_val(*buff)-1)*W;
-+         size = (hdrsize(*buff)-1)*W;
-          if (len > size) return IFALSE;
-          wrote = write(fd, ((char *)buff)+W, len);
-          if (wrote > 0) return F(wrote);
-@@ -751,7 +759,7 @@ static word prim_sys(int op, word a, word b, word c) {
-          word *buff = (word *) b;
-          int wrote, size, len = fixval(c);
-          if (immediatep(buff)) return IFALSE;
--         size = (imm_val(*buff)-1)*W;
-+         size = (hdrsize(*buff)-1)*W;
-          if (len > size) return IFALSE;
-          wrote = send(fd, ((char *)buff)+W, len, 0); /* <- no MSG_DONTWAIT in win32 */
-          if (wrote > 0) return F(wrote);
-@@ -839,9 +847,9 @@ word boot(int nargs, char **argv) {
-       hp = (unsigned char *) &heap;
-    }
-    max_heap_mb = (W == 4) ? 4096 : 65535; /* can be set at runtime */
--   memstart = genstart = fp = (word *) realloc(NULL, (FMAX + MEMPAD)*W); /* at least one argument string always fits */
-+   memstart = genstart = fp = (word *) realloc(NULL, (INITCELLS + FMAX + MEMPAD)*W); /* at least one argument string always fits */
-    if (!memstart) exit(3);
--   memend = memstart + FMAX - MEMPAD;
-+   memend = memstart + FMAX + INITCELLS - MEMPAD;
-    this = nargs-1;
-    usegc = 1;
-    while(this >= 0) { /* build an owl string list to oargs at bottom of heap */
-@@ -857,6 +865,8 @@ word boot(int nargs, char **argv) {
-       }
-       size = ((len % W) == 0) ? (len/W)+1 : (len/W) + 2;
-       if ((word)fp + size >= (word)memend) {
-+         printf("oargs gc\n");
-+         exit(2);
-          oargs = gc(FMAX, oargs); /* oargs points to topmost pair, may move as a result of gc */
-          fp = oargs + 3;
-       }
-@@ -873,8 +883,10 @@ word boot(int nargs, char **argv) {
-       fp += 3;
-       this--;
-    }
-+   //fprintf(stderr, "AAAAAAAAAAAAAAAAAAAAAAAAAAAA\n");
-    nobjs = count_objs(&nwords);
-    oargs = gc(nwords+(128*1024), oargs); /* get enough space to load the heap without triggering gc */
-+   //fprintf(stderr, "AAAAAAAAAAAAAAAAAAAAAAAAAAAA\n");
-    fp = oargs + 3;
-    ptrs = fp;
-    fp += nobjs+1;
-@@ -914,6 +926,7 @@ word vm(word *ob, word *args) {
-    static word R[NR];
-    word load_imms[] = {F(0), INULL, ITRUE, IFALSE};  /* for ldi and jv */
-    usegc = 1; /* enble gc (later have if always evabled) */
-+   //fprintf(stderr, "VM STARTED\n");
- 
-    /* clear blank regs */
-    while(acc < NR) { R[acc++] = INULL; }
-@@ -923,6 +936,7 @@ word vm(word *ob, word *args) {
-    acc = 2; /* boot always calls with 2 args*/
- 
- apply: /* apply something at ob to values in regs, or maybe switch context */
-+   //fprintf(stderr, "VM APPLY\n");
-    if (likely(allocp(ob))) {
-       word hdr = *ob & 4095;
-       if (hdr == 262) { /* proc  */ 
-@@ -1020,6 +1034,7 @@ invoke: /* nargs and regs ready, maybe gc and execute ob */
- 
-    if (op) {
-       main_dispatch:
-+      //fprintf(stderr, "vm: %d\n", op);
-       EXEC;
-    } else {
-       op = *ip<<8 | ip[1];
-@@ -1222,7 +1237,7 @@ invoke: /* nargs and regs ready, maybe gc and execute ob */
-       word hdr, pos = 1, n = *ip++;
-       assert(allocp(tuple), tuple, 32);
-       hdr = *tuple;
--      assert_not((rawp(hdr) || fixval(hdr)-1 != n), tuple, 32);
-+      assert_not((rawp(hdr) || hdrsize(hdr)-1 != n), tuple, 32);
-       while(n--) { R[*ip++] = tuple[pos++]; }
-       NEXT(0); }
-    op33: { /* jrt a t o, jump by raw type (ignoring padding info) */
-@@ -1250,7 +1265,7 @@ invoke: /* nargs and regs ready, maybe gc and execute ob */
-       NEXT(4); }
-    op36: { /* size o r */
-       word *ob = (word *) R[*ip++];
--      R[*ip++] = (immediatep(ob)) ? F(0) : F(imm_val(*ob)-1);
-+      R[*ip++] = (immediatep(ob)) ? F(0) : F(hdrsize(*ob)-1);
-       NEXT(0); }
-    op37: { /* ms r */
- #ifndef WIN32
diff --git a/owl/ol.scm b/owl/ol.scm
index 4ea3f4e..f804f4d 100644
--- a/owl/ol.scm
+++ b/owl/ol.scm
@@ -694,17 +694,18 @@ Check out http://code.google.com/p/owl-lisp for more information.")
                << < <= = >= > >> 
                equal? has? mem
                band bor bxor
-               sort suffix-array 
-               bisect bisect-range
+               sort
+               ; suffix-array bisect
                fold foldr for map reverse length zip append unfold
                lref lset iota
-               vec-ref vec-len vec-fold vec-foldr
+               ;vec-ref vec-len vec-fold vec-foldr
                ;print 
                mail interact 
                take keep remove 
                thread-controller
                ;sexp-parser 
-               rand seed->rands))))
+               rand seed->rands
+               ))))
 
 (import (owl usuals))
 
